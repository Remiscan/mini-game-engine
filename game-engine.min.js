export class Game{constructor(t=function(){},s=function(){},{canvas:e=document.querySelector("canvas"),html:i=document.querySelector("accessible-elements"),state:a={},actions:o={},levels:n=[],tickRate:h=60}={}){this.canvas=e.getContext("2d"),this.html=i,this.state=a,this.state.actions=o,this.state.level=null,this.width=e.width,this.height=e.height,this.audioCtx=null,this.paused=!1,this.mute=!1,this.levels=n,this.start=t.bind(this),this.tickRate=h;const c=1e3/this.tickRate;const l=new Worker(URL.createObjectURL(new Blob(["computing = false; port = null; update =",s.toString(),"; onmessage =",function(t){if(self.computing)return;const s=JSON.parse(t.data);if("init"===s.type)return void(self.port=t.ports[0]);self.computing=!0;const{state:e,actions:i,ticks:a}=s,o=self.update(e,i,a);self.port.postMessage(JSON.stringify(o)),self.computing=!1}.toString()],{type:"text/javascript"}))),r=new MessageChannel;l.postMessage(JSON.stringify({type:"init"}),[r.port2]),r.port1.onmessage=t=>this.state=JSON.parse(t.data);const d=t=>{t<=0||(this.lastTick+=t*c,l.postMessage(JSON.stringify({state:this.state,actions:this.currentActions,ticks:t})))};this.gameLoop=function t(s){if(this.stopLoop=window.requestAnimationFrame(t.bind(this)),this.paused)return;let e=0;if(s>this.lastTick+c){const t=s-this.lastTick;e=Math.floor(t/c)}d(e),this.render(),this.lastRender=s}.bind(this)}play(){if(!(this.state.level instanceof Level))throw"No level loaded";this.initControls(),this.audioCtx=new(AudioContext||webkitAudioContext),this.lastTick=performance.now(),this.lastRender=this.lastTick,this.start(),this.gameLoop(performance.now())}render(){this.canvas.clearRect(0,0,this.width,this.height);const t=this.state.level.camera;console.log(this.state);const s=this.state.level.objects.sort(((t,s)=>t.z<s.z?-1:t.z>s.z?1:0));for(const e of s){const s=this.position.x-t.x,i=this.position.y-t.y;s<-e.width||i<-e.height||s>this.width||i>this.height||(e.sprite?canvas.drawImage(this.sprite,s,i,this.width,this.height):e.draw(this.canvas))}}addLevel(t){const s=new Level(this,t);return this.levels.push(s),s}async loadLevel(t){this.pause=!0;const s=this.levels.find((s=>s.id===t));await s.load(),this.state.level=s,this.pause=!1}playSound(t){if(this.mute)return;const s=this.audioCtx.createBufferSource(),e=this.state.level.sounds.findIndex((s=>s.id==t));if(-1==e)throw`Sound ${t} doesn't exist`;s.buffer=this.state.level.sounds[e].sound,s.connect(this.audioCtx.destination),s.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",(t=>{const s=t.code||t.key;this.state.actions.filter((t=>t.controls.includes(s))).map((t=>t.active=!0))})),document.addEventListener("keyup",(t=>{const s=t.code||t.key;this.state.actions.filter((t=>t.controls.includes(s))).map((t=>t.active=!1))}))}get currentActions(){return this.state.actions.filter((t=>t.active)).map((t=>t.name))}}class Level{constructor(t,{id:s=null,width:e=null,height:i=null,objects:a=[],sounds:o=[]}){this.id=s||t.levels.length,this.width=e||t.width,this.height=i||t.height,this.objects=a,this.sounds=o.map((t=>({id:t,sound:null}))),this.camera={x:0,y:0,z:0,angle:0,perspective:0}}async load(){let t=await Promise.all(this.sounds.map((t=>fetch(`./assets/${t}.mp3`))));t=await Promise.all(t.map((t=>t.arrayBuffer()))),t=await Promise.all(t.map((t=>audioCtx.decodeAudioData(t)))),this.sounds=this.sounds.map(((s,e)=>({id:s,sound:t[e]})))}addObject(t){const s=new GameObject(this,t);return this.objects.push(s),s}moveCamera({x:t,y:s,z:e=0,angle:i=0}={}){const a=Object.assign({},this.camera);this.camera={x:t,y:s,z:e,angle:i};const o=a.x-this.camera.x,n=a.y-this.camera.y,h=a.z-this.camera.z;a.angle,this.camera.angle;for(const t of this.objects)t.moveTo(t.position.x+o,t.position.y+n,t.position.z+h)}}class GameObject{constructor({x:t=0,y:s=0,z:e=0,width:i=0,height:a=0,sprite:o=null,draw:n=(t=>{}),collision:h=!1,damage:c=!1}){this.position={x:t,y:s,z:e},this.destination={x:t,y:s,z:e},this.speed=0,this.width=i,this.height=a,this.sprite=o,this.draw=n,this.collision=h,this.damage=c}moveTo(t,s,e){}}