export class Game{constructor(t,e,{canvas:s=document.querySelector("canvas"),html:i=document.querySelector("accessible-elements"),state:a={},actions:n={},levels:o=new Set,frameRate:h=60}={}){this.canvas=s,this.html=i,this.state=a,this.state.actions=n,this.width=s.width,this.height=s.height,this.frameRate=h,this.audioCtx=null,this.paused=!1,this.mute=!1,this.levels=o,this.currentLevel=null,this.start=t.bind(this),this.update=e.bind(this)}play(){this.initControls(),this.start();const t=function*(){let t=0;for(;;)this.currentLevel?.objects.map((t=>t.update())),this.currentLevel?.update(),this.update(),yield t,t++}.bind(this)();setInterval((()=>{this.paused||t.next()}),1e3/this.frameRate)}addLevel(...t){const e=new Level(this,...t);this.levels.add(e)}async loadLevel(t){this.currentLevel=this.levels.find((e=>e.id===t)),null===this.audioCtx&&(this.audioCtx=new(window.AudioContext||window.webkitAudioContext));let e=await Promise.all(this.currentLevel.sounds.map((t=>fetch(`./assets/${t}.mp3`))));e=await Promise.all(e.map((t=>t.arrayBuffer()))),e=await Promise.all(e.map((t=>audioCtx.decodeAudioData(t)))),this.currentLevel.sounds=this.currentLevel.sounds.map(((t,s)=>({id:t,sound:e[s]})))}playSound(t){if(this.mute)return;const e=this.audioCtx.createBufferSource(),s=this.currentLevel.sounds.findIndex((e=>e.id==t));if(-1==s)throw`Sound ${t} doesn't exist`;e.buffer=this.currentLevel.sounds[s].sound,e.connect(this.audioCtx.destination),e.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",(t=>{const e=t.code||t.key;this.state.actions.filter((t=>t.controls.includes(e))).map((t=>t.active=!0))})),document.addEventListener("keyup",(t=>{const e=t.code||t.key;this.state.actions.filter((t=>t.controls.includes(e))).map((t=>t.active=!1))}))}get currentActions(){return this.state.actions.filter((t=>t.active)).map((t=>t.name))}}export class Level{constructor(t,e,s,{width:i=null,height:a=null,objects:n=new Set,sounds:o=[]}){this.game=t,this.width=i||this.game.width,this.height=a||this.game.height,this.objects=n,this.sounds=o.map((t=>({id:t,sound:null}))),this.cameraCoordinates={x:0,y:0,z:0,angle:0},this.start=e.bind(this),this.update=s.bind(this)}addObject(...t){const e=new GameObject(this,...t);this.objects.add(e)}set camera(t,e,s=0,i=0){const a=Object.assign({},this.cameraCoordinates);this.cameraCoordinates={x:t,y:e,z:s,angle:i};const n=a.x-this.cameraCoordinates.x,o=a.y-this.cameraCoordinates.y,h=a.z-this.cameraCoordinates.z;a.angle,this.cameraCoordinates.angle;for(const t of this.objects)t.moveTo(t.position.x+n,t.position.y+o,t.position.z+h)}get camera(){return this.cameraCoordinates}}export class GameObject{constructor(t,e,s,{x:i=0,y:a=0,z:n=0,width:o=0,height:h=0,sprite:d=null,collision:r=!1,damage:c=!1}){this.level=t,this.game=this.level.game,this.position={x:i,y:a,z:n},this.width=o,this.height=h,this.sprite=d,this.collision=r,this.damage=c,this.start=e.bind(this),this.update=s.bind(this)}moveTo(t,e,s){}}