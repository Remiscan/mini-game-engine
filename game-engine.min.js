class g{canvasElement;canvasCtx;html;width;height;audioCtx;mute=!1;paused=!1;levels=[];assets=[];actions=new Map([["up",["ArrowUp","KeyW"]],["down",["ArrowDown","KeyS"]],["left",["ArrowLeft","KeyA"]],["right",["ArrowRight","KeyD"]]]);controls=new Map([]);start;state={actions:new Set};rendering=!1;lastRender=0;renderLoop;computing=!1;tickRate=60;lastTick=0;gameLoop;constructor(t=function(){},i=function(n){},{canvas:s=document.querySelector("canvas"),html:e=document.querySelector(".accessible-elements"),tickRate:o=60}={}){if(s==null)throw"Invalid canvas";this.canvasElement=s;const n=s.getContext("2d");if(n==null)throw"Invalid canvas context";if(this.canvasCtx=n,e==null)throw"Invalid accessible elements container";this.html=e,this.width=s.width,this.height=s.height;for(const a of this.actions.keys())for(const h of this.actions.get(a)||[])this.controls.set(h,!1);this.start=t.bind(this);const p=async(a=performance.now())=>{const h=this.render.bind(this);let r=!1;const d=()=>window.requestAnimationFrame(h);r||(this.canvasElement.addEventListener("renderend",d),r=!0),window.requestAnimationFrame(h)};this.renderLoop=p.bind(this),this.tickRate=o;const l=1e3/this.tickRate,m=async a=>{a<=0||this.computing||(this.computing=!0,this.lastTick+=a*l,this.state.actions=this.currentActions,i.bind(this)(a),this.computing=!1)},c=async a=>{if(window.requestAnimationFrame(c.bind(this)),this.paused)return;const h=this.lastTick+l;let r=0;if(a>h){const d=a-this.lastTick;r=Math.floor(d/l)}m(r)};this.gameLoop=c.bind(this)}async play(){if(this.audioCtx=new AudioContext,this.initControls(),this.lastTick=performance.now(),this.lastRender=this.lastTick,await this.start(),!(this.state.level instanceof w))throw"No level loaded";this.renderLoop(),this.gameLoop(performance.now())}render(t){if(this.rendering||this.paused)return;this.canvasElement.dispatchEvent(new CustomEvent("renderstart",{detail:{time:performance.now()}})),this.rendering=!0,this.lastRender=t,this.canvasCtx.clearRect(0,0,this.width,this.height);const i=this.state.level?.camera||{x:0,y:0,z:0,perspective:0},s=[...this.state.level?.objects||[]].sort((e,o)=>e.position.z<o.position.z?-1:e.position.z>o.position.z?1:0);for(const e of s){this.canvasCtx.save();let o=new Path2D;o.rect(Math.max(0,-i.x),Math.max(0,-i.y),Math.min(e.level.width,this.width),Math.min(e.level.height,this.height)),this.canvasCtx.clip(o),this.canvasCtx.translate(-i.x,-i.y),e.draw(this.canvasCtx,{x:e.position.x,y:e.position.y,game:this}),this.canvasCtx.restore()}this.rendering=!1,this.canvasElement.dispatchEvent(new CustomEvent("renderend",{detail:{time:performance.now()}}))}addActions(t){for(const i of t.keys()){const s=t.get(i)||[];s.length>0&&this.actions.set(i,s)}}addSound(t,i){this.assets.push({type:"sound",id:t,path:i})}addImage(t,i){this.assets.push({type:"image",id:t,path:i})}addLevel(t){const i=new w(this,t);return this.levels.push(i),i}async loadLevel(t){this.paused=!0;const i=this.levels.find(s=>s.id===t);await i?.load(),this.state.level=i,this.paused=!1}playSound(t){if(this.mute||!this.audioCtx)return;const i=this.audioCtx.createBufferSource(),s=this.assets.find(e=>e.id==t)?.data;if(typeof s>"u")throw`Sound ${t} doesn't exist`;i.buffer=s,i.connect(this.audioCtx.destination),i.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",t=>{if(t.repeat)return;const i=t.code||t.key;typeof this.controls.get(i)!==void 0&&this.controls.set(i,!0)}),document.addEventListener("keyup",t=>{const i=t.code||t.key;typeof this.controls.get(i)!==void 0&&this.controls.set(i,!1)})}get currentActions(){const t=this.actions.keys(),i=new Set;for(const s of t)for(const e of this.actions.get(s)||[])this.controls.get(e)&&i.add(s);return i}}class w{game;id;width;height;objects=new Set;camera;audioCtx;constructor(t,{id:i=null,width:s=null,height:e=null}={}){this.game=t,this.id=i||t.levels.length,this.width=s||t.width,this.height=e||t.height,this.objects=new Set,this.camera={x:this.width<t.width?(this.width-t.width)/2:0,y:this.height<t.height?(this.height-t.height)/2:0,z:0,perspective:0},this.audioCtx=t.audioCtx}async load(){const t=new Set;for(const s of this.objects)for(const e of s.assets)t.add(e);await Promise.all([...t].map(async s=>{if(s.data)return s.data;let e=await fetch(s.path),o;switch(s.type){case"sound":{const n=await e.arrayBuffer();o=await this.audioCtx?.decodeAudioData(n)}break;case"image":{const n=await e.blob();o=await createImageBitmap(n)}break}return s.data=o}));const i=this.game.state.level;if(i instanceof w){const s=new Set;for(const e of i.objects)for(const o of e.assets)s.add(o);for(const e of s)t.has(e)||(e.data=null)}}addObject(t){const i=new f(this,t);return this.objects.add(i),i}moveCamera({x:t,y:i,z:s,angle:e}={x:0,y:0,z:0,angle:0}){const o=Object.assign({},this.camera);this.camera={x:t,y:i,z:s,angle:e};const n={x:o.x-this.camera.x,y:o.y-this.camera.y,z:o.z-this.camera.z,angle:(o.angle||0)-(this.camera.angle||0)};for(const p of this.objects);}}class f{level;game;id;position;maxSpeed;speed={x:0,y:0,z:0};angle=0;state={};width;height;draw;collision;damage;controllable;assets;constructor(t,{id:i="",position:s={x:0,y:0,z:0},maxSpeed:e=0,width:o=0,height:n=0,assets:p=[],draw:l=function(){},collision:m=!1,damage:c=!1,controllable:a=!1}={}){this.level=t,this.game=t.game,this.id=i,this.position=s,this.maxSpeed=e,this.width=o,this.height=n,this.draw=l.bind(this),this.collision=m,this.damage=c,this.controllable=a,this.assets=this.game.assets.filter(h=>p.includes(h.id))}move({apply:t=!0}={}){const i=Object.assign({},this.position),s=this.width,e=this.height;let o=this.position.x+this.speed.x,n=this.position.y+this.speed.y;const l=new f(this.level,{position:{x:o,y:n,z:0},width:s,height:e,collision:!0}).allCollisions({exclude:[this],forceCollision:!1});if(l.length>0){const c=l.map(u=>this.distanceTo(u)),a={x:Math.min(...c.map(u=>u.x)),y:Math.min(...c.map(u=>u.y))};o+=a.x,n+=a.y;const h=new f(this.level,{position:{x:o,y:i.y,z:0},width:s,height:e,collision:!0}),r=new f(this.level,{position:{x:i.x,y:n,z:0},width:s,height:e,collision:!0}),d=h.allCollisions({exclude:[this],forceCollision:!1}).length>0,x=r.allCollisions({exclude:[this],forceCollision:!1}).length>0;d&&!x?o-=this.speed.x:x&&!d?n-=this.speed.y:(o-=this.speed.x,n-=this.speed.y)}return t&&(this.position=Object.assign(this.position,{x:o,y:n})),{x:o,y:n,z:0}}moveByVector({x:t,y:i},s){const e=t/Math.sqrt(t**2+i**2),o=i*Math.sqrt(1-e**2),n=this.maxSpeed;return this.speed={x:n*e,y:n*o,z:0},this.move(s)}collidesWith(t){return(this.position.x<=t.position.x&&this.position.x+this.width>t.position.x||this.position.x<t.position.x+t.width&&this.position.x+this.width>=t.position.x+t.width)&&(this.position.y<=t.position.y&&this.position.y+this.height>t.position.y||this.position.y<t.position.y+t.height&&this.position.y+this.height>=t.position.y+t.height)}allCollisions({exclude:t,forceCollision:i}={exclude:[],forceCollision:!1}){const s=[];for(const e of this.level.objects)e===this||t.includes(e)||!i&&(!this.collision||!e.collision)||this.collidesWith(e)&&s.push(e);return s}distanceTo(t){let i=0,s=0;return this.collidesWith(t)||(t.position.x+t.width<this.position.x?i=t.position.x+t.width-this.position.x:this.position.x+this.width<t.position.x&&(i=t.position.x-(this.position.x+this.width)),t.position.y+t.height<this.position.y?s=t.position.y+t.height-this.position.y:this.position.y+this.height<t.position.y&&(s=t.position.y-(this.position.y+this.height))),{x:i,y:s,z:0}}}export{g as Game,f as GameObject,w as Level};
