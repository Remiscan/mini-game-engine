export class Game{constructor(t=function(){},s=function(){},{canvas:e=document.querySelector("canvas"),html:i=document.querySelector("accessible-elements"),state:a={},actions:n={},levels:o=new Set,tickRate:c=60}={}){this.canvas=e,this.html=i,this.state=a,this.state.actions=n,this.state.level=null,this.width=e.width,this.height=e.height,this.audioCtx=null,this.paused=!1,this.mute=!1,this.levels=o,this.start=t.bind(this),this.tickRate=c;const h=1e3/this.tickRate;const r=new Worker(URL.createObjectURL(new Blob(["computing = false; port = null; update =",s.toString(),"; onmessage =",function(t){if(self.computing)return;const s=JSON.parse(t.data);if("init"===s.type)return void(self.port=t.ports[0]);self.computing=!0;const{state:e,actions:i,ticks:a}=s,n=self.update(e,i,a);self.port.postMessage(JSON.stringify(n)),self.computing=!1}.toString()],{type:"text/javascript"}))),d=new MessageChannel;r.postMessage(JSON.stringify({type:"init"}),[d.port2]),d.port1.onmessage=t=>this.state=JSON.parse(t.data);const l=t=>{t<=0||(this.lastTick+=t*h,r.postMessage(JSON.stringify({state:this.state,actions:this.currentActions,ticks:t})))};this.gameLoop=function t(s){if(this.stopLoop=window.requestAnimationFrame(t.bind(this)),this.paused)return;let e=0;if(s>this.lastTick+h){const t=s-this.lastTick;e=Math.floor(t/h)}l(e),this.render(),this.lastRender=s}.bind(this)}play(){this.initControls(),this.audioCtx=new(AudioContext||webkitAudioContext),this.lastTick=performance.now(),this.lastRender=this.lastTick,this.start(),this.gameLoop(performance.now())}render(){}addLevel(...t){const s=new Level(this,...t);this.levels.add(s)}async playLevel(t){this.pause=!0;const s=this.levels.find((s=>s.id===t));await s.play(),this.game.state.level=s,this.pause=!1}playSound(t){if(this.mute)return;const s=this.audioCtx.createBufferSource(),e=this.state.level.sounds.findIndex((s=>s.id==t));if(-1==e)throw`Sound ${t} doesn't exist`;s.buffer=this.state.level.sounds[e].sound,s.connect(this.audioCtx.destination),s.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",(t=>{const s=t.code||t.key;this.state.actions.filter((t=>t.controls.includes(s))).map((t=>t.active=!0))})),document.addEventListener("keyup",(t=>{const s=t.code||t.key;this.state.actions.filter((t=>t.controls.includes(s))).map((t=>t.active=!1))}))}get currentActions(){return this.state.actions.filter((t=>t.active)).map((t=>t.name))}}class Level{constructor(t,s=function(){},e=function(){},{width:i=null,height:a=null,objects:n=new Set,sounds:o=[]}){this.width=i||t.width,this.height=a||t.height,this.objects=n,this.sounds=o.map((t=>({id:t,sound:null}))),this.cameraCoordinates={x:0,y:0,z:0,angle:0,perspective:0},this.start=s.bind(this),this.update=e.bind(this)}async load(){let t=await Promise.all(this.sounds.map((t=>fetch(`./assets/${t}.mp3`))));t=await Promise.all(t.map((t=>t.arrayBuffer()))),t=await Promise.all(t.map((t=>audioCtx.decodeAudioData(t)))),this.sounds=this.sounds.map(((s,e)=>({id:s,sound:t[e]})))}async play(){await this.load(),this.start()}addObject(...t){const s=new GameObject(this,...t);this.objects.add(s)}set camera({x:t,y:s,z:e=0,angle:i=0}={}){const a=Object.assign({},this.cameraCoordinates);this.cameraCoordinates={x:t,y:s,z:e,angle:i};const n=a.x-this.cameraCoordinates.x,o=a.y-this.cameraCoordinates.y,c=a.z-this.cameraCoordinates.z;a.angle,this.cameraCoordinates.angle;for(const t of this.objects)t.moveTo(t.position.x+n,t.position.y+o,t.position.z+c)}get camera(){return this.cameraCoordinates}}class GameObject{constructor({x:t=0,y:s=0,z:e=0,width:i=0,height:a=0,sprite:n=null,collision:o=!1,damage:c=!1}){this.position={x:t,y:s,z:e},this.destination={x:t,y:s,z:e},this.speed=0,this.width=i,this.height=a,this.sprite=n,this.collision=o,this.damage=c}moveTo(t,s,e){}}