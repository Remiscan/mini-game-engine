export class Game{constructor(t=function(){},s=function(){},i=[],{canvas:e=document.querySelector("canvas"),html:o=document.querySelector("accessible-elements"),state:n={},actions:h={},levels:a=[],tickRate:c=60}={}){this.canvas=e.getContext("2d"),this.html=o,this.width=e.width,this.height=e.height,this.audioCtx=null,this.paused=!1,this.mute=!1,this.levels=a;this.actions=Object.assign({up:["ArrowUp","KeyW"],down:["ArrowDown","KeyS"],left:["ArrowLeft","KeyA"],right:["ArrowRight","KeyD"]},h),this.controls={};for(const t of Object.keys(this.actions))for(const s of this.actions[t])this.controls[s]=!1;this.state=n,this.state.level=null,this.state.actions=[],this.start=t.bind(this),this.tickRate=c;const r=1e3/this.tickRate;this.computing=!1,this.rendering=!1;const l=t=>{t<=0||this.computing||(this.computing=!0,this.lastTick+=t*r,this.state.actions=this.currentActions,s.bind(this)(t),this.computing=!1)};this.gameLoop=function t(s){if(this.stopLoop=window.requestAnimationFrame(t.bind(this)),this.paused)return;let i=0;if(s>this.lastTick+r){const t=s-this.lastTick;i=Math.floor(t/r)}l(i),this.render(s)}.bind(this)}async play(){if(this.initControls(),this.audioCtx=new(AudioContext||webkitAudioContext),this.lastTick=performance.now(),this.lastRender=this.lastTick,await this.start(),!(this.state.level instanceof Level))throw"No level loaded";this.gameLoop(performance.now())}render(t){if(this.rendering)return;this.rendering=!0,this.lastRender=t,this.canvas.clearRect(0,0,this.width,this.height);const s=this.state.level.camera,i=this.state.level.objects.sort(((t,s)=>t.z<s.z?-1:t.z>s.z?1:0));for(const t of i){const i=t.position.x-s.x,e=t.position.y-s.y;i<-t.width||e<-t.height||i>this.width||e>this.height||(t.sprite?canvas.drawImage(t.sprite,i,e,this.width,this.height):t.draw(this.canvas))}this.rendering=!1}addLevel(t){const s=new Level(this,t);return this.levels.push(s),s}async loadLevel(t){this.pause=!0;const s=this.levels.find((s=>s.id===t));await s.load(),this.state.level=s,this.pause=!1}playSound(t){if(this.mute)return;const s=this.audioCtx.createBufferSource(),i=this.state.level.sounds.findIndex((s=>s.id==t));if(-1==i)throw`Sound ${t} doesn't exist`;s.buffer=this.state.level.sounds[i].sound,s.connect(this.audioCtx.destination),s.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",(t=>{if(t.repeat)return;const s=t.code||t.key;void 0!==typeof this.controls[s]&&(this.controls[s]=!0)})),document.addEventListener("keyup",(t=>{const s=t.code||t.key;void 0!==typeof this.controls[s]&&(this.controls[s]=!1)}))}get currentActions(){const t=Object.keys(this.actions),s=new Set;for(const i of t)for(const t of this.actions[i])!0===this.controls[t]&&s.add(i);return[...s]}}class Level{constructor(t,{id:s=null,width:i=null,height:e=null,objects:o=[],sounds:n=[]}){this.id=s||t.levels.length,this.width=i||t.width,this.height=e||t.height,this.objects=o,this.sounds=n.map((t=>({id:t,sound:null}))),this.camera={x:0,y:0,z:0,angle:0,perspective:0}}async load(){let t=await Promise.all(this.sounds.map((t=>fetch(`./assets/${t}.mp3`))));t=await Promise.all(t.map((t=>t.arrayBuffer()))),t=await Promise.all(t.map((t=>audioCtx.decodeAudioData(t)))),this.sounds=this.sounds.map(((s,i)=>({id:s,sound:t[i]})))}addObject(t){const s=new GameObject(t);return this.objects.push(s),s}moveCamera({x:t,y:s,z:i=0,angle:e=0}={}){const o=Object.assign({},this.camera);this.camera={x:t,y:s,z:i,angle:e};const n=o.x-this.camera.x,h=o.y-this.camera.y,a=o.z-this.camera.z;o.angle,this.camera.angle;for(const t of this.objects)t.moveTo(t.position.x+n,t.position.y+h,t.position.z+a)}}class GameObject{constructor({position:t={x:0,y:0,z:0},width:s=0,height:i=0,sprite:e=null,draw:o=function(){},collision:n=!1,damage:h=!1,controllable:a=!1}){this.position=t,this.destination=null,this.speed=0,this.maxSpeed=5,this.width=s,this.height=i,this.sprite=e,this.draw=o.bind(this),this.collision=n,this.damage=h,this.controllable=a}moveTo(t,s,i){const e=t===this.position.x?s>this.position.y?Math.PI/2:-Math.PI/2:s===this.position.y?t>this.position.x?0:Math.PI:Math.atan(Math.PI/180*(s-this.position.y)/(t-this.position.x));return{x:this.position.x+Math.cos(e)*this.maxSpeed,y:this.position.y+Math.sin(e)*this.maxSpeed,z:i}}}