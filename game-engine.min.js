export class Game{constructor(t=function(){},s=function(){},i=[],{canvas:e=document.querySelector("canvas"),html:o=document.querySelector("accessible-elements"),state:a={},actions:n={},levels:h=[],tickRate:c=60}={}){this.canvas=e.getContext("2d"),this.html=o,this.width=e.width,this.height=e.height,this.audioCtx=null,this.paused=!1,this.mute=!1,this.levels=h;this.actions=Object.assign({up:["ArrowUp","KeyW"],down:["ArrowDown","KeyS"],left:["ArrowLeft","KeyA"],right:["ArrowRight","KeyD"]},n),this.controls={};for(const t of Object.keys(this.actions))for(const s of this.actions[t])this.controls[s]=!1;this.state=a,this.state.level=null,this.state.actions=[],this.start=t.bind(this),this.tickRate=c;const r=1e3/this.tickRate;this.computing=!1,this.rendering=!1;const l=t=>{t<=0||this.computing||(this.computing=!0,this.lastTick+=t*r,this.state.actions=this.currentActions,s.bind(this)(t),this.computing=!1)};this.gameLoop=function t(s){if(this.stopLoop=window.requestAnimationFrame(t.bind(this)),this.paused)return;let i=0;if(s>this.lastTick+r){const t=s-this.lastTick;i=Math.floor(t/r)}l(i),this.render(s)}.bind(this)}async play(){if(this.initControls(),this.audioCtx=new(AudioContext||webkitAudioContext),this.lastTick=performance.now(),this.lastRender=this.lastTick,await this.start(),!(this.state.level instanceof Level))throw"No level loaded";this.gameLoop(performance.now())}render(t){if(this.rendering)return;this.rendering=!0,this.lastRender=t,this.canvas.clearRect(0,0,this.width,this.height);const s=this.state.level.camera,i=this.state.level.objects.sort(((t,s)=>t.z<s.z?-1:t.z>s.z?1:0));for(const t of i){const i=t.position.x-s.x,e=t.position.y-s.y;i<-t.width||e<-t.height||i>this.width||e>this.height||(this.canvas.save(),t.draw(this.canvas,{x:i,y:e,game:this}),this.canvas.restore())}this.rendering=!1}addLevel(t){const s=new Level(this,t);return this.levels.push(s),s}async loadLevel(t){this.pause=!0;const s=this.levels.find((s=>s.id===t));await s.load(),this.state.level=s,this.pause=!1}playSound(t){if(this.mute)return;const s=this.audioCtx.createBufferSource(),i=this.state.level.sounds.findIndex((s=>s.id==t));if(-1==i)throw`Sound ${t} doesn't exist`;s.buffer=this.state.level.sounds[i].sound,s.connect(this.audioCtx.destination),s.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",(t=>{if(t.repeat)return;const s=t.code||t.key;void 0!==typeof this.controls[s]&&(this.controls[s]=!0)})),document.addEventListener("keyup",(t=>{const s=t.code||t.key;void 0!==typeof this.controls[s]&&(this.controls[s]=!1)}))}get currentActions(){const t=Object.keys(this.actions),s=new Set;for(const i of t)for(const t of this.actions[i])!0===this.controls[t]&&s.add(i);return[...s]}}export class Level{constructor(t,{id:s=null,width:i=null,height:e=null}={}){this.game=t,this.id=s||t.levels.length,this.width=i||t.width,this.height=e||t.height,this.objects=[],this.assets=[],this.camera={x:0,y:0,z:0,angle:0,perspective:0},this.audioCtx=t.audioCtx}async load(){return await Promise.all(this.assets.map((async t=>{let s=await fetch(t.path);switch(t.type){case"sound":s=await s.arrayBuffer(),s=await this.audioCtx.decodeAudioData(s);break;case"image":s=await s.blob(),s=await createImageBitmap(s);break}return"sound"===t.type&&(s=await s.arrayBuffer(),s=await this.audioCtx.decodeAudioData(s)),t.data=s})))}addObject(t){const s=new GameObject(this,t);return this.objects.push(s),s}getObject(t){return this.objects.find((s=>s.id===t))}addSound(t,s){this.assets.push({type:"sound",id:t,path:s})}addImage(t,s){this.assets.push({type:"image",id:t,path:s})}moveCamera({x:t,y:s,z:i=0,angle:e=0}={}){const o=Object.assign({},this.camera);this.camera={x:t,y:s,z:i,angle:e};const a=o.x-this.camera.x,n=o.y-this.camera.y,h=o.z-this.camera.z;o.angle,this.camera.angle;for(const t of this.objects)t.moveTo(t.position.x+a,t.position.y+n,t.position.z+h)}static objectsCollide(t,s){return!(t.position.x+t.width<s.position.x||s.position.x+s.width<t.position.x||t.position.y+t.height<s.position.y||s.position.y+s.height<t.position.y)}}export class GameObject{constructor(t,{id:s=null,position:i={x:0,y:0,z:0},width:e=0,height:o=0,assets:a=[],draw:n=function(){},collision:h=!1,damage:c=!1,controllable:r=!1}={}){this.level=t,this.game=t.game,this.id=s,this.position=i,this.speed=0,this.maxSpeed=5,this.width=e,this.height=o,this.draw=n.bind(this),this.collision=h,this.damage=c,this.controllable=r,this.assets=t.assets.filter((t=>a.includes(t.id)))}moveTo(t,s,i){const e=t===this.position.x?s>this.position.y?Math.PI/2:-Math.PI/2:s===this.position.y?t>this.position.x?0:Math.PI:Math.atan(Math.PI/180*(s-this.position.y)/(t-this.position.x));return{x:this.position.x+Math.cos(e)*this.maxSpeed,y:this.position.y+Math.sin(e)*this.maxSpeed,z:i}}collidesWith(t){return Level.objectsCollide(this,t)}allCollisions(){const t=this.level.objects,s=[];for(const i of t)i!==this&&!1!==i.collision&&this.collidesWith(i)&&s.push(i);return s}}