export class Game{constructor(t=function(){},i=function(){},s=[],{canvas:e=document.querySelector("canvas"),html:o=document.querySelector("accessible-elements"),state:h={},actions:n={},levels:a=[],tickRate:c=60}={}){this.canvas=e.getContext("2d"),this.html=o,this.width=e.width,this.height=e.height,this.audioCtx=null,this.paused=!1,this.mute=!1,this.levels=a;this.actions=Object.assign({up:["ArrowUp","KeyW"],down:["ArrowDown","KeyS"],left:["ArrowLeft","KeyA"],right:["ArrowRight","KeyD"]},n),this.controls={};for(const t of Object.keys(this.actions))for(const i of this.actions[t])this.controls[i]=!1;this.state=h,this.state.level=null,this.state.actions=[],this.start=t.bind(this),this.tickRate=c;const l=1e3/this.tickRate;this.computing=!1,this.rendering=!1;const d=t=>{t<=0||this.computing||(this.computing=!0,this.lastTick+=t*l,this.state.actions=this.currentActions,i.bind(this)(t),this.computing=!1)};this.gameLoop=function t(i){if(this.stopLoop=window.requestAnimationFrame(t.bind(this)),this.paused)return;let s=0;if(i>this.lastTick+l){const t=i-this.lastTick;s=Math.floor(t/l)}d(s),this.render(i)}.bind(this)}async play(){if(this.initControls(),this.audioCtx=new(AudioContext||webkitAudioContext),this.lastTick=performance.now(),this.lastRender=this.lastTick,await this.start(),!(this.state.level instanceof Level))throw"No level loaded";this.gameLoop(performance.now())}render(t){if(this.rendering)return;this.rendering=!0,this.lastRender=t,this.canvas.clearRect(0,0,this.width,this.height);const i=this.state.level.camera,s=this.state.level.objects.sort(((t,i)=>t.z<i.z?-1:t.z>i.z?1:0));for(const t of s){const s=t.position.x-i.x,e=t.position.y-i.y;s<-t.width||e<-t.height||s>this.width||e>this.height||(this.canvas.save(),t.draw(this.canvas,{x:s,y:e,game:this}),this.canvas.restore())}this.rendering=!1}addLevel(t){const i=new Level(this,t);return this.levels.push(i),i}async loadLevel(t){this.pause=!0;const i=this.levels.find((i=>i.id===t));await i.load(),this.state.level=i,this.pause=!1}playSound(t){if(this.mute)return;const i=this.audioCtx.createBufferSource(),s=this.state.level.sounds.findIndex((i=>i.id==t));if(-1==s)throw`Sound ${t} doesn't exist`;i.buffer=this.state.level.sounds[s].sound,i.connect(this.audioCtx.destination),i.start()}pause(){this.paused=!0}unpause(){this.paused=!1}initControls(){document.addEventListener("keydown",(t=>{if(t.repeat)return;const i=t.code||t.key;void 0!==typeof this.controls[i]&&(this.controls[i]=!0)})),document.addEventListener("keyup",(t=>{const i=t.code||t.key;void 0!==typeof this.controls[i]&&(this.controls[i]=!1)}))}get currentActions(){const t=Object.keys(this.actions),i=new Set;for(const s of t)for(const t of this.actions[s])!0===this.controls[t]&&i.add(s);return[...i]}}export class Level{constructor(t,{id:i=null,width:s=null,height:e=null}={}){this.game=t,this.id=i||t.levels.length,this.width=s||t.width,this.height=e||t.height,this.objects=[],this.assets=[],this.camera={x:0,y:0,z:0,angle:0,perspective:0},this.audioCtx=t.audioCtx}async load(){return await Promise.all(this.assets.map((async t=>{let i=await fetch(t.path);switch(t.type){case"sound":i=await i.arrayBuffer(),i=await this.audioCtx.decodeAudioData(i);break;case"image":i=await i.blob(),i=await createImageBitmap(i);break}return"sound"===t.type&&(i=await i.arrayBuffer(),i=await this.audioCtx.decodeAudioData(i)),t.data=i})))}addObject(t){const i=new GameObject(this,t);return this.objects.push(i),i}getObject(t){return this.objects.find((i=>i.id===t))}addSound(t,i){this.assets.push({type:"sound",id:t,path:i})}addImage(t,i){this.assets.push({type:"image",id:t,path:i})}moveCamera({x:t,y:i,z:s=0,angle:e=0}={}){const o=Object.assign({},this.camera);this.camera={x:t,y:i,z:s,angle:e};const h=o.x-this.camera.x,n=o.y-this.camera.y,a=o.z-this.camera.z;o.angle,this.camera.angle;for(const t of this.objects)t.moveTo(t.position.x+h,t.position.y+n,t.position.z+a)}}export class GameObject{constructor(t,{id:i=null,position:s={x:0,y:0,z:0},maxSpeed:e=0,width:o=0,height:h=0,assets:n=[],draw:a=function(){},collision:c=!1,damage:l=!1,controllable:d=!1}={}){this.level=t,this.game=t.game,this.id=i,this.position=s,this.maxSpeed=e,this.speed={x:0,y:0},this.angle=0,this.width=o,this.height=h,this.draw=a.bind(this),this.collision=c,this.damage=l,this.controllable=d,this.assets=t.assets.filter((t=>n.includes(t.id)))}move({apply:t=!0}={}){const i=Object.assign({},this.position),s=this.width,e=this.height;let o=this.position.x+this.speed.x,h=this.position.y+this.speed.y;const n=new GameObject(this.level,{position:{x:o,y:h},width:s,height:e,collision:!0}).allCollisions({exclude:[this]});if(n.length>0){const t=n.map((t=>this.distanceTo(t))),a={x:Math.min(t.map((t=>t.x))),y:Math.min(t.map((t=>t.y)))};o+=a.x,h+=a.y;const c=new GameObject(this.level,{position:{x:o,y:i.y},width:s,height:e,collision:!0}),l=new GameObject(this.level,{position:{x:i.x,y:h},width:s,height:e,collision:!0}),d=c.allCollisions({exclude:[this]}).length>0,r=l.allCollisions({exclude:[this]}).length>0;d&&!r?o-=this.speed.x:(r&&!d||(o-=this.speed.x),h-=this.speed.y)}return t&&(this.position=Object.assign(this.position,{x:o,y:h})),{x:o,y:h}}moveByVector({x:t,y:i},s){const e=t/Math.sqrt(t**2+i**2),o=i*Math.sqrt(1-e**2),h=this.maxSpeed;this.speed={x:h*e,y:h*o},this.move(s)}collidesWith(t){return(this.position.x<=t.position.x&&this.position.x+this.width>t.position.x||this.position.x<t.position.x+t.width&&this.position.x+this.width>=t.position.x+t.width)&&(this.position.y<=t.position.y&&this.position.y+this.height>t.position.y||this.position.y<t.position.y+t.height&&this.position.y+this.height>=t.position.y+t.height)}allCollisions({exclude:t=[],forceCollision:i=!1}={}){const s=this.level.objects,e=[];for(const o of s)o===this||t.includes(o)||(i||this.collision&&o.collision)&&this.collidesWith(o)&&e.push(o);return e}distanceTo(t){let i=0,s=0;return this.collidesWith(t)||(t.position.x+t.width<this.position.x?i=t.position.x+t.width-this.position.x:this.position.x+this.width<t.position.x&&(i=t.position.x-(this.position.x+this.width)),t.position.y+t.height<this.position.y?s=t.position.y+t.height-this.position.y:this.position.y+this.height<t.position.y&&(s=t.position.y-(this.position.y+this.height))),{x:i,y:s}}}